---
description: Акторная модель и ее свойства
---

# Actor Model

Данная модель была разработана для конкурентных/параллельных вычислений еще полвека назад. Она определяет некоторые ключевые правила как системные компоненты должны себя вести и как взаимодействовать друг с другом.

Один из самых популярных языков программирования, использующих эту модель - [Erlang](https://erlang.org) (акторная модель лежит в основе его виртуальной машины BEAM). Erlang в качестве акторов использует легковесные процессы в рамках своей виртуальной машины. Эти процессы обмениваются между собой сообщениями, в том числе и между распределенными процессами. Так реализуется сетевая прозрачность для акторов.

Существуют также реализации этой модели и в других языках. Например, в JAVA есть [фреймворк Akka](https://akka.io). Он предоставляет очень мощьный инструмент для создания решений на основе акторной модели, но, к сожалению, не предоставляет возможности работать с инфраструктурой Erlang нативно.

Ergo Framework реализует акторную модель с готовыми дизайн-паттернами (behaviors), а также реализует полный сетевой стек Erlang (протокол DIST и формат данных ETF. смотрите раздел [ETF/DIST](distributed-nodes/etf-dist.md)). Это дает возможность интегрироваться с инфраструктурой Erlang нативным образом, без необходимости транскодирования данных или адаптации механизмов взаимодействия акторов (обмен сообщениями, линковка, мониторинг).

### Актор

Актором является базовая единица вычислительной системы. В Ergo Framwork в качестве актора используется надстройка над легковесным процессом goroutine - [gen.Process](process.md). Взаимодействие между акторами производится через асинхронные сообщения и каждый актор имеет "почтовый ящик" для них. Объем такого ящика в Ergo Framework можно задать при старте актора `node.Spawn(...)` используя параметр `gen.ProcessOptions{MailboxSize: N, ...}`. Обработка почтового ящика производится последовательно в порядке очереди FIFO. Больше подробностей о процессе и параметрах его запуска можно прочитать в разделах [gen.Process](process.md) и [gen.ProcessOptions](../advanced/process-options.md). На базе gen.Process в Ergo Framework созданы готовые дизайн-паттерны ([behaviors](behavior.md)) [gen.Server](../generic-behaviors/server/), [gen.Supervisor](../generic-behaviors/supervisor.md), [gen.Application](../generic-behaviors/application.md).

Одним из ключевых особенностей актора gen.Server является изолированный state процесса, доступ которому имеет только сам процесс.&#x20;

Помимо получения сообщений и их последующей обработки, актор может:

* отправлять асинхронные сообщения используя `gen.Process.Send(...)` , `gen.ServerProcess.Cast(...)`&#x20;
* делать синхронные вызовы используя `gen.ServerProcess.Call(...)`&#x20;
* создавать новые акторы используя `gen.Process.Spawn(...)`
* модифицировать свой state в процессе обработки входящих сообщений

### Отказоустойчивость

В отличие от Erlang, где изолированность процессов гарантируется виртуальной машиной BEAM, в Golang нет возможности полностью изолировать влияние goroutine друг на друга в случае краха одной из них. Однако, Golang предоставляется возможность обработки состояния паники goroutine используя механизм recover.

В Ergo Framework каждый актор имеет обработку состояния паники goroutine. Это дает возможность избежать краха всего приложения. Вместе с этим, необходимо быть внимательным при создании собственных goroutines. Отсутсвие обработчика состояния паники приведет к падению всего приложения. Убидитесь, что ваш код содержит обработку таких ситуаций.

Помимо обработки исключительных ситуаций, когда актор завершает работу аварийно, иногда могут возникать ситуации при которых актор перестает обрабатывать входящие сообщения или обрабатывает их медленнее, чем поступают новые сообщения. Причины такого поведения могут быть различными - актор работает с большим объемом данных или с медленной СУБД, или из-за ошибки программиста возник dead-lock на каком-нибудь мьютексе. В этой связи очередь сообщений переполняется. При переполнении очереди сообщений процесса в Ergo Framework вновь приходящие сообщения будут либо отбрасываться (а на стандартный вывод будет выводиться соответствующее предупреждение), либо пересылаться другому процессу, если таковой был указан в опциях запуска процесса как запасной `gen.ProcessOptions.Fallback`.

### Распределенные вычисления и сетевая прозрачность

Одной из ключевых возможностей Ergo Framework - сетевая прозрачность. Она обеспечивается благодаря использованию унифицированного формата адреса получателя и сетевого стека - протокол DIST и формат данных ETF. Таким образом, вы можете не думать о сетевой части взаимодействия между акторами, запущенными на разных нодах - когда вы отправляете сообщение процессу, который принадлежит удаленной ноде, Ergo Framework автоматически создаст сетевое подлючение с ней и отправит сообщение заданному процессу.&#x20;

