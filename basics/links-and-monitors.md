---
description: Механизмы связывания процессов
---

# Links And Monitors

Как вы уже знаете, взаимодействие между процессами происходит посредством обмена сообщениями. Однако, этого механизма недостаточно, если необходимо реагировать на внезапное завершение процесса. Для этих целей были разработаны две дополнительные формы коммуникации между процессами - связывание и мониторинг.&#x20;

### Связывание процессов

Связывание двух процессов является двунаправленным механизмом коммуникации. Это значит, если один из двух процессов завершит свою работу (вне зависимости, аварийно или штатно), второй процесс будет остановлен. Для этих целей интерфейс `gen.Process` предоставляет несколько методов:

* `Link(with etf.Pid) error` создает связку с процессом, указанным в качестве аргумента `with`. Связывание возможно как с локальным процессом, так и с удаленным.
* `Unlink(with etf.Pid) error` удаляет связку с указанным процессом
* `Links() []etf.Pid` позволяет получить список процессов, с которыми связан этот процесс

Существует также возможность перехватить событие завершения работы связанного процесса, чтобы предотвратить завершение работы второго процесса. Для этого у каждого процесса есть флаг `TrapExit`, который может быть установлен с помощью метода `gen.Process.SetTrapExit(trap bool)`.  Если он установлен в `true`, то событие о завершении связанного процесса будет трансформированно в сообщение `gen.MessageExit` и вы получите его в callback метод `HandleInfo(...)` вашего `gen.Server` процесса. Поле `Reason` в `gen.MessageExit` может иметь следующие значения:

* причина завершения процесса_._ Если процесс завершился из-за паники, то будет предоставлена краткая информация из бектрейса этого события.&#x20;
* `noproc` если вы создали связку на процесс, который не существовал на момент создания этой связки. Для локального процесса в этом случае метод `Link(...)` вернет ошибку `node.ErrProcessUnknown`
* `noconnection` если создали связку на удаленный процесс, к ноде которого не удалось осуществить подключение или оно было разорвано после создания связки. _Это значит, что процесс на удаленной ноде может оставаться живым_.
* `noproxy` если была создана связка на удаленный процесс, к ноде которого соединение было создано через прокси-ноды и одна из таких нод была остановлена (или утрачена связь с ней). _Как и в случае с "noconnection", процесс на удаленной ноде может оставаться живым._

Повторный вызов метода `Link(...)`, при уже существующей связке, вернет ошибку `"already linked"`.

{% hint style="info" %}
Связывание двух процессов возможно только с использованием идентификатора процесса `etf.Pid`.&#x20;
{% endhint %}

### Мониторинг процесса

Это однонаправленный механизм коммуникации между двумя процессами. Событие о завершении процесса получит только тот процесс, который установил этот мониторинг. В отличие от связывания, мониторинг можно устанавливать не только по идентификатору процесса `etf.Pid`, но и по имени процесса. Как и в связывании, этот процесс может быть как локальным, так и удаленным. Для работы с функцией мониторинга процессов интерфейс `gen.Process` предоставляет следующие методы:

* `MonitorProcess(process interface{}) etf.Ref` этот метод создает монитор (тип `etf.Ref`) на указанный процесс. В качестве аргумента может быть имя локального процесса (тип `string` или `etf.Atom`), идентификатор процесса `etf.Pid`, либо имя удаленного процесса (`gen.ProcessID`). Повторный вызов этого метода на тот же процесс создает новый монитор (новым значением `etf.Ref`) и ваш процесс получит ровно столько сообщений `gen.MessageDown`, сколько было установлено мониторов на завершенный процесс. Отличаться эти сообщения будут только полем `gen.MessageDown.Ref` со значением идентификатора монитора. Поле `Reason` в `gen.MessageDown` может иметь следующие значения:
  * причина завершения процесса_._ Если процесс завершился из-за паники, то будет предоставлена краткая информация из бектрейса этого события.&#x20;
  * `noproc` если вы создали монитор на процесс, который не существовал на момент создания этого монитора
  * `noconnection` если создали монитор на удаленный процесс, к ноде которого не удалось осуществить подключение или оно было разорвано после создания монитора. _Это значит, что процесс на удаленной ноде может оставаться живым_.
  * `noproxy` если был создана монитор на удаленный процесс, к ноде которого соединение было создано через прокси-ноды и одна из таких нод была остановлена (или утрачена связь с ней). _Как и в случае с "noconnection", процесс на удаленной ноде может оставаться живым._

{% hint style="info" %}
Если монитор был установлен по имени процесса, то сообщение `gen.MessageDown` будет содержать имя процесса в поле `gen.MessageDown.ProcessID`. Поле `Pid` будет пустым. Для монитора, установленного по идентификатору процесса `etf.Pid` поле `gen.MessageDown.Pid` будет содержать идентификатор процесса, а поле `gen.MessageDown.ProcessID` останется пустым.
{% endhint %}

* `DemonitorProcess(ref etf.Ref) bool` удаляет ранее созданный монитор
* `Monitors() []etf.Pid` возвращает список мониторов, созданных по идентификатору процесса etf.Pid.
* `MonitorsByName() []gen.ProcessID` возвращает список мониторов, созданных по имени процесса
* `MonitoredBy() []etf.Pid` возвращает список идентификаторов процессов, которые создали монитор на этот процесс.

{% hint style="info" %}
Фунция мониторинга процесса похожа на фунцию связывания с включенным флагом `TrapExit` (чтобы избежать останов процесса при завершении связанного процесса). Однако, между ними есть ключевая разница - используя флаг `TrapExit` вы определяете главенство одного процесса над другим. Это значит, что завершение одного процесса не обязывает к завершению второй (на котором включен этот флаг), однако завершение второго процесса обязывает к завершению первого процесса. Именно эта особенность используется в реализации `gen.Supervisor`, где завершение _Supervisor_-процесса должно приводить к завершению всех его дочерних процессов, однако завершение дочернего должно лишь помогать _Supervisor_-процессу делать выбор стратегии рестарта дочернего процесса.
{% endhint %}

### Мониторинг ноды

Процесс также может создать монитор на удаленную ноду (в действительности, создается монитор на соединение с удаленной нодой). Для этих целей в интерфейсе `gen.Process` представленно два метода:

* `MonitorNode(name string) etf.Ref` создает монитор на удаленную ноду
* `DemonitorNode(ref etf.Ref) bool` удаляет созданный ранее монитор

Как и в случае мониторинга процессов, повторный вызов метода `MonitorNode` с тем же именем удаленной ноды создет новый монитор. При потере соединения с этой нодой процесс получит ровно столько сообщений `gen.MessageNodeDown`, сколько было создано мониторов.

Если вы создаете монитор на удаленную ноду, подключение к которой осуществлено через прокси-ноду, то при потере связи с этой нодой процесс получит сообщение `gen.MessageProxyDown`.
