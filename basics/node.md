---
description: Что такое Нода в Ergo Framework
---

# Node

Нода - это ядро сервиса, который вы создаете с помощью Ergo Framework. В это ядро включена подсистема управления процессами, подсистема маршрутизации сообщений, подсистема управления линками и мониторами, а также сетевой стек, который обеспечивает сетевую прозрачность. Помимо этого, нода дает гибкие механизмы для создания собственных компонентов ядра (см. раздел [Customization](../advanced/customization/)).

### Управление процессами

Механизм запуска и остановки процессов целиком обеспечивается ядром ноды. Каждый процесс регистрируется под собственным уникальным идентификатором `etf.Pid`. Благодаря идентификаторам процессов осуществляется маршрутизация сообщений. Также обеспечивается регистрация имен и алиасов для процессов, а при остановке процесса их освобождение.

Процессы, основанные на `gen.Application` (приложения) являются специализированными, поскольку они имеют расширенный набор аттрибутов. Запуск приложений осуществляется в два этапа. Сначала производится загрузка приложения используя метод `node.Node.ApplicationLoad(...)`, после чего оно становится доступно для старта используя метод `node.Node.ApplicationStart(...)`. Более подробно о приложениях, их свойствах и методах работы с ними вы можете почитать в разделе [Application](../generic-behaviors/application.md).

Помимо этого, нода дает возможность запуска процессов на удаленной ноде или удаленного вызова RPC-функций. Более подробно о возможностях ноды для распределенных вычислений вы можете прочитать в разделе [Distributed Nodes](distributed-nodes/).

### Маршрутизация сообщений

Еще одной ключевой задачей ноды является маршрутизация сообщений между процессами. При этом сама маршрутизация прозрачна как для процесса-отправителя так и для процесса-получателя. Если процесс-получатель находится на удаленной ноде, то нода автоматически попытается создать к ней сетевое подключение и отправить сообщение адресату.

Маршрутизация сообщений производится не только по идентификатору процесса `etf.Pid`. Сообщение может быть также адресовано используя:&#x20;

* Имя локального процесса.
* `etf.Alias`. Удобная возможность "одноразовой" адресации, если не хочется оперировать `etf.Pid` или зарегистрированным именем процесса. Для создания алиаса необходимо воспользоваться методом `gen.Process.CreateAlias`

{% hint style="info" %}
Эта опция адресации появилась в Ergo Framework 2.0.0 как поддержка Erlang/OTP 24.0. В Erlang ee создали для решения ситуации, когда отправитель делал синхронный запрос, но таймаут ожидания ответа происходил раньше, чем приходил ответ. В этом случае процесс получал этот ответ как обычное сообщение, которое необходимо было обрабатывать. Чтобы исключить такие "фантомные" сообщения, был придуман механизм алиасов для процессов. Это временные идентификаторы для процесса. Если сообщение было адресовано по алиасу, который перестал существовать, то сообщение отбрасывается.

В Ergo Framework таких "фантомных" сообщений не может возникнуть в силу особенностей реализации механизма синхнронных вызовов в `gen.Server`. Тем не менее, наличие функциоанала алиасов является полезным, т.к. расширяет возможности адресации процессов.
{% endhint %}

* `gen.ProcessID`. Используется для отправки сообщения получателю на удаленной ноде по имени процесса получателя.

### Управление линками и мониторами

Помимо обмена сообщениями, процессы могут следить за другими процессами, связываться с ними. Для этого в ноде существует два механизма:

* Мониторинг процесса. C помощью метода `gen.Process.MonitorProcess(...)` любой процесс может следить за другим процессом (по имени или по идентификатору `etf.Pid`), в том числе и на удаленной ноде. В задачу ноды входит информирование процесса (отправка сообщения `gen.MessageDown`), осуществляющего мониторинг, в случае остановки процесса, за которым осуществляется слежение, с указанием причины завершения.
* Связывание процессов. Осуществтляется с помощью метода `gen.Process.Link(...)`. Связывание возможно только по идентификатору процесса `etf.Pid`, при этом процесс может быть на удаленной ноде. Отличается от функции мониторинга тем, что при остановке одного процесса, связанный процесс также должен быть остановлен. Нода отвечает не только за сигнализацию о завершении процесса, но и за завершение работы второго.

Также, нода предоставляет механизм слежения за удаленными нодами. Для этого необходимо использовать метод `gen.Process.MonitorNode(...)`. Если произойдет разрыв сетевого подключения с удаленной нодой, то процесс будет информирован сообщением `gen.MessageNodeDown`.&#x20;

{% hint style="info" %}
Для прокси подключений используется сообщение gen.MessageProxyDown
{% endhint %}

Подробнее о функциях мониторинга и связывания читайте в разделе [Links And Monitors](links-and-monitors.md)

### Сетевой стек

Сетевое взаимодействие для процессов является прозрачным. Нода самостоятельно создает подключение к удаленным нодам при необходимости и кодирует данные для передачи по сети. Она также учитывает параметры статической маршрутизаци, если такие были заданы с использованием `node.Node.AddStaticRoute(...)` или параметры прокси соединения, которые могут быть заданы с помощью метода `node.Node.AddProxyRoute(...)`.

Для передачи по сети данные кодируются в бинарный формат ETF, а сетевое взаимодействие осуществляется с помощью протокола DIST. Процесс отправки данных состоит из нескольких этапов:

* Кодирование данных в бинарный ETF формат с учетом Atom-кеша. Этот механизм позволяет оптимизировать объем пересылаемых данных, если в них активно используется тип данных etf.Atom.
* Сжатие бинарных данных, если в процессе-отправителе была включена опция сжатия используя метод `gen.Process.SetCompression(...)` и объем сжимаемых данных больше заданного порога с помощью метода `gen.Process.SetCompressionThreshold(...)`.&#x20;
* Шифрование бинарных данных, если они передаются по прокси-соединению с включеной опцией end-to-end шифрования.
* Фрагментация бинарных данных, если их объем превышает размер пакета, заданный в опциях сетевого протокола

Более детальную информацию о сетевом взаимодействии, формате ETF и протоколе DIST вы можете прочитать в разделе [Distributed Nodes](distributed-nodes/).

### Старт ноды

Для старта ноды в первую очередь необходимо определить ее имя. Оно состоит из двух частей `{name}@{hostname}.` Номер порта для входящих подключений выбирается динамически, либо можно указать явно номер используя опцию `node.Options.Listen`, либо диапазон портов опциями `node.Options.ListenBegin` и `node.Options.ListenEnd`.

На одном хосте может быть запущено множество нод, но все они должны иметь уникальные имена. Контроль уникальности имен для запускаемых нод на хосте, осуществляется с помощью встроенного в ноду EMPD сервиса. Он выполняет функцию регистратора запущенных нод. При старте ноды EMPD сервис пытается запуститься в режиме сервера, используя порт 4369. Если этот порт уже занят, то он переключается в режим клиента и подключается к этому порту для регистрации ноды. Это подключение остается живым до момента останова ноды. &#x20;

{% hint style="info" %}
EPMD - это Erlang Port Mapper Daemon. В Erlang это отдельная программа, которая запускается Erlang-нодой при первом старте и остается запущенной все время, пока ее явно не остановят. В Ergo Framework этот функционал встроен в ноду.&#x20;

Реализация EPMD в Ergo Framework полностью совместима с реализацией Erlang, поэтому Erlang ноды успешно подключаются к EMPD серверу, встроенному в ноду на базе Ergo Framework и наоборот.
{% endhint %}

Регистрация ноды включает в себя предоставление информации об имени ноды, номера порта для входящих подключений, а также набор флагов cо служебной информацией.

В задачу EPMD входит не только регистрация нод, но и функция определения порта по имени ноды. Каждая нода, при попытке подключиться к удаленной ноде сначала обращается к EPMD серверу, запущенному на том же хосте, где запущена удаленная нода, с запросом номера порта по имени ноды. Получив его, производится установка сетевого подключения между нодами с последующей процедурой хендшейка.

Для EPMD разрыв такого соединения означает останов ноды. Для ноды разрыв такого соединения (если она не завершает свою работу) означает, что другая нода, выполняющая функцию EPMD-сервера была остановлена. В этом случае EPMD клиент ноды старается переключиться в режим сервера, чтобы выполнять функцию регистратора для остальных нод, запущенных на этом хосте.



Если при старте ноды в опции node.Options.Applications указаны приложения, то они будут автоматически запущены.&#x20;

### Останов ноды



