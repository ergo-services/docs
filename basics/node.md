---
description: Что такое Нода в Ergo Framework
---

# Node

Нода - это ядро сервиса, который вы создаете с помощью Ergo Framework. В это ядро включена подсистема управления процессами, подсистема маршрутизации сообщений, подсистема управления линками и мониторами, а также сетевой стек, который обеспечивает сетевую прозрачность. Помимо этого, нода дает гибкие механизмы для создания собственных компонентов ядра (см. раздел [Customization](../advanced/customization/)).

### Управление процессами

Механизм запуска и остановки процессов целиком обеспечивается ядром ноды. Каждый процесс регистрируется под собственным уникальным идентификатором `etf.Pid`. Благодаря идентификаторам процессов осуществляется маршрутизация сообщений. Также обеспечивается регистрация имен и алиасов для процессов, а при остановке процесса их освобождение.

Процессы, основанные на `gen.Application` (приложения) являются специализированными, поскольку они имеют расширенный набор аттрибутов. Запуск приложений осуществляется в два этапа. Сначала производится загрузка приложения используя метод `node.Node.ApplicationLoad(...)`, после чего оно становится доступно для старта используя метод `node.Node.ApplicationStart(...)`. Более подробно о приложениях, их свойствах и методах работы с ними вы можете почитать в разделе [Application](../generic-behaviors/application.md).

Помимо этого, нода дает возможность запуска процессов на удаленной ноде или удаленного вызова RPC-функций. Более подробно о возможностях ноды для распределенных вычислений вы можете прочитать в разделе [Distributed Nodes](distributed-nodes/).

### Маршрутизация сообщений

Еще одной ключевой задачей ноды является маршрутизация сообщений между процессами. При этом сама маршрутизация прозрачна как для процесса-отправителя так и для процесса-получателя. Если процесс-получатель находится на удаленной ноде, то нода автоматически попытается создать к ней сетевое подключение и отправить сообщение адресату.

Маршрутизация сообщений производится не только по идентификатору процесса `etf.Pid`. Сообщение может быть также адресовано используя:&#x20;

* Имя локального процесса.
* `etf.Alias`. Удобная возможность "одноразовой" адресации, если не хочется оперировать `etf.Pid` или зарегистрированным именем процесса. Для создания алиаса необходимо воспользоваться методом `gen.Process.CreateAlias`

{% hint style="info" %}
Эта опция адресации появилась в Ergo Framework 2.0.0 как поддержка Erlang/OTP 24.0. В Erlang ee создали для решения ситуации, когда отправитель делал синхронный запрос, но таймаут ожидания ответа происходил раньше, чем приходил ответ. В этом случае процесс получал этот ответ как обычное сообщение, которое необходимо было обрабатывать. Чтобы исключить такие "фантомные" сообщения, был придуман механизм алиасов для процессов. Это временные идентификаторы для процесса. Если сообщение было адресовано по алиасу, который перестал существовать, то сообщение отбрасывается.

В Ergo Framework таких "фантомных" сообщений не может возникнуть в силу особенностей реализации механизма синхнронных вызовов в `gen.Server`. Тем не менее, наличие функциоанала алиасов является полезным, т.к. расширяет возможности адресации процессов.
{% endhint %}

* `gen.ProcessID`. Используется для отправки сообщения получателю на удаленной ноде по имени процесса получателя.

### Управление линками и мониторами

Помимо обмена сообщениями, процессы могут следить за другими процессами, связываться с ними. Для этого в ноде существует два механизма:

* Мониторинг процесса. C помощью метода `gen.Process.MonitorProcess(...)` любой процесс может следить за другим процессом (по имени или по идентификатору `etf.Pid`), в том числе и на удаленной ноде. В задачу ноды входит информирование процесса (отправка сообщения `gen.MessageDown`), осуществляющего мониторинг, в случае остановки процесса, за которым осуществляется слежение, с указанием причины завершения.
* Связывание процессов. Осуществтляется с помощью метода `gen.Process.Link(...)`. Связывание возможно только по идентификатору процесса `etf.Pid`, при этом процесс может быть на удаленной ноде. Отличается от функции мониторинга тем, что при остановке одного процесса, связанный процесс также должен быть остановлен. Нода отвечает не только за сигнализацию о завершении процесса, но и за завершение работы второго.

Также, нода предоставляет механизм слежения за удаленными нодами. Для этого необходимо использовать метод `gen.Process.MonitorNode(...)`. Если произойдет разрыв сетевого подключения с удаленной нодой, то процесс будет информирован сообщением `gen.MessageNodeDown`.&#x20;

{% hint style="info" %}
Для прокси подключений используется сообщение gen.MessageProxyDown
{% endhint %}

Подробнее о функциях мониторинга и связывания читайте в разделе [Links And Monitors](links-and-monitors.md)

### Сетевой стек

Сетевое взаимодействие для процессов является прозрачным. Нода самостоятельно создает подключение к удаленным нодам при необходимости и кодирует данные для передачи по сети. Она также учитывает параметры статической маршрутизаци, если такие были заданы с использованием `node.Node.AddStaticRoute(...)` или параметры прокси соединения, которые могут быть заданы с помощью метода `node.Node.AddProxyRoute(...)`.

Для передачи по сети данные кодируются в бинарный формат ETF, а сетевое взаимодействие осуществляется с помощью протокола DIST. Процесс отправки данных состоит из нескольких этапов:

* Кодирование данных в бинарный ETF формат с учетом Atom-кеша. Этот механизм позволяет оптимизировать объем пересылаемых данных, если в них активно используется тип данных etf.Atom.
* Сжатие бинарных данных, если в процессе-отправителе была включена опция сжатия используя метод `gen.Process.SetCompression(...)` и объем сжимаемых данных больше заданного порога с помощью метода `gen.Process.SetCompressionThreshold(...)`.&#x20;
* Шифрование бинарных данных, если они передаются по прокси-соединению с включеной опцией end-to-end шифрования.
* Фрагментация бинарных данных, если их объем превышает размер пакета, заданный в опциях сетевого протокола

Более детальную информацию о сетевом взаимодействии, формате ETF и протоколе DIST вы можете прочитать в разделе [Distributed Nodes](distributed-nodes/).

### Старт ноды

Для старта ноды в первую очередь необходимо определить ее имя. Оно состоит из двух частей `{name}@{hostname}.` Также, обязательным является указание параметра cookie. Он предназначен для сетевого взаимодействия с удаленными нодами. Ниже приведен пример запуска ноды:

```go
import (
    "github.com/ergo-services/ergo"
    "github.com/ergo-services/ergo/node"
)

func main() {
    name := "example@localhost"
    cookie := "secret"
    opts := node.Options{}
    exampleNode, err := ergo.StartNode(name, cookie, opts)
    
    // 
    // start here applications/servers etc.
    //
    
    // press Ctrl+C or call exampleNode.Stop() somewhere else.
    exampleNode.Wait()
}
```

Если при старте ноды в опции `node.Options.Applications` указаны приложения, то они будут автоматически запущены. Однако, если какое-то из приложений не сможет запуститься, то функция `ergo.StartNode(...)` вернет ошибку, а сама нода остановится.

Вы также можете использовать функцию `ergo.StartNodeWithContext(...),` если хотите, чтобы нода задействовала внешний контекст. Например, вы можете ограничить время жизни ноды, создав контекст ограниченный по времени с помощью `context.WithTimeout(...)` или `context.WithDeadline(...)`.

Используя `node.Options.Env` можно указать переменные окружения для ноды. Все запускаемые процессы на этой ноде наследуют эти переменные. Интерфейс `node.Node` предоставляет возможность управлять переменными окружения с помощью методов `ListEnv()`, `SetEnv(...)` и `Env(...)`. Однако, изменения в переменных окружения отражаются только на вновь запускаемых процессах.

Поле `node.Options.Creation` определяет инкарнацию ноды. Это поле можно оставить пустым и оно автоматически получит значение `uint32(time.Now().Unix()).` Это значение будет присутствовать во всех процессах, запущенных на этой ноде. Оно позволяет удаленным нодам контролировать корректность идентификатора процесса. Больше информации о процессе в разделе [Process](process.md).&#x20;

В опциях ноды также можно определить параметры сжатия данных для запускаемых процессов. Значения опции node.Options.Compression будут использованы как значения по-умолчанию для запускаемых процессов на этой ноде. Сжатие применяется только для данных, отправляемых на удаленную ноду.

Остальные опции в `node.Options` относятся к сетевому взаимодействию и подробно описаны в разделе [Distributed Nodes](distributed-nodes/).&#x20;

### Останов ноды

Остановить ноду можно двумя способами:

* явно вызвать метод node.Node.Stop()
* оспользовать внешний контекст, который можно отменить или ограничить по времени

Все процессы, запущенные на ноде будут автоматически остановлены, используя контекст ноды. Все сетевые подключения будут разорваны, а открытые порты для входящих соединений закрыты.

{% hint style="info" %}
При остановке ноды, завершение процессов иногда происходит быстрее, чем разрываются сетевые соединения с удаленными нодами и ядро ноды успевает отослать уведомления об остановке процессов (если они имели линки или мониторы с удаленных нод). Таким образом, очередность событий, возникающих на удаленных нодах является непределенной. В некоторых случаях gen.MessageDown будет иметь в поле Reason значение "noconnection" (это значит сетевое подключение было разорвано) или значение "kill" (это значит, что останавливаемая нода успела послать событие остановки процесса до того как сетевое соединение было разорвано).
{% endhint %}

