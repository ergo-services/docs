---
description: Что такое Нода в Ergo Framework
---

# Node

Нода - это ядро сервиса, который вы создаете с помощью Ergo Framework. В это ядро включена подсистема управления процессами, подсистема маршрутизации сообщений, подсистема управления линками и мониторами, а также сетевой стек, который обеспечивает сетевую прозрачность. Помимо этого, нода дает гибкие механизмы для создания собственных компонентов ядра (см. раздел [Customization](../advanced/customization/)).

### Управление процессами

Механизм запуска и остановки процессов целиком обеспечивается ядром ноды. Каждый процесс регистрируется под собственным уникальным идентификатором `etf.Pid`. Благодаря идентификаторам процессов осуществляется маршрутизация сообщений. Также обеспечивается регистрация имен и алиасов для процессов, а при остановке процесса их освобождение.

Процессы, основанные на `gen.Application` (приложения) являются специализированными, поскольку они имеют расширенный набор аттрибутов. Запуск приложений осуществляется в два этапа. Сначала производится загрузка приложения используя метод `node.Node.ApplicationLoad(...)`, после чего оно становится доступно для старта используя метод `node.Node.ApplicationStart(...)`. Более подробно о приложениях, их свойствах и методах работы с ними вы можете почитать в разделе [Application](../generic-behaviors/application.md).

Помимо этого, нода дает возможность запуска процессов на удаленной ноде или удаленного вызова RPC-функций. Более подробно о возможностях ноды для распределенных вычислений вы можете прочитать в разделе [Distributed Nodes](distributed-nodes/).

### Маршрутизация сообщений

Еще одной ключевой задачей ноды является маршрутизация сообщений между процессами. При этом сама маршрутизация прозрачна как для процесса-отправителя так и для процесса-получателя. Если процесс-получатель находится на удаленной ноде, то нода автоматически попытается создать к ней сетевое подключение и отправить сообщение адресату.

Маршрутизация сообщений производится не только по идентификатору процесса `etf.Pid`. Сообщение может быть также адресовано используя:&#x20;

* Имя локального процесса.
* `etf.Alias`. Удобная возможность "одноразовой" адресации, если не хочется оперировать `etf.Pid` или зарегистрированным именем процесса. Для создания алиаса необходимо воспользоваться методом `gen.Process.CreateAlias`

{% hint style="info" %}
Эта опция адресации появилась в Ergo Framework 2.0.0 как поддержка Erlang/OTP 24.0. В Erlang ee создали для решения ситуации, когда отправитель делал синхронный запрос, но таймаут ожидания ответа происходил раньше, чем приходил ответ. В этом случае процесс получал этот ответ как обычное сообщение, которое необходимо было обрабатывать. Чтобы исключить такие "фантомные" сообщения, был придуман механизм алиасов для процессов. Это временные идентификаторы для процесса. Если сообщение было адресовано по алиасу, который перестал существовать, то сообщение отбрасывается.

В Ergo Framework таких "фантомных" сообщений не может возникнуть в силу особенностей реализации механизма синхнронных вызовов в `gen.Server`. Тем не менее, наличие функциоанала алиасов является полезным, т.к. расширяет возможности адресации процессов.
{% endhint %}

* `gen.ProcessID`. Используется для отправки сообщения получателю на удаленной ноде по имени процесса получателя.

### Управление линками и мониторами

Помимо обмена сообщениями, процессы могут следить за другими процессами, связываться с ними. Для этого в ноде существует два механизма:

* Мониторинг процесса. C помощью метода `gen.Process.MonitorProcess(...)` любой процесс может следить за другим процессом (по имени или по идентификатору `etf.Pid`), в том чиле и на удаленной ноде. В задачу ноды входит информирование процесса (отправка сообщения `gen.MessageDown`), осуществляющего мониторинг, в случае остановки процесса, за которым осуществляется слежение, с указанием причины завершения.
* Связывание процессов. Осуществтляется с помощью метода `gen.Process.Link(...)`. Связывание возможно только по идентификатору процесса `etf.Pid`, при этом процесс может быть на удаленной ноде. Отличается от функции мониторинга тем, что при остановке одного процесса, связанный процесс также должен быть остановлен. Нода отвечает не только за сигнализацию о завершении процесса, но и за завершение работы второго.

Подробнее о функциях мониторинга и связывания читайте в разделе [Links And Monitors](links-and-monitors.md)

### Сетевой стек

статический раут, прокси раут

### Старт ноды

Если при старте ноды в опции node.Options.Applications указаны приложения, то они будут автоматически запущены.&#x20;

### Останов ноды



