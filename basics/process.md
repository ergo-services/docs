# Process

Процесс в Ergo Framework - это актор в виде надстройки над легковесной goroutine, в которую включен набор необходимых методов и свойств. Взаимодействие между такими процессами производится с помощью обмена сообщениями. Для этих целей в процессе имеется mailbox, куда помещаются все входящие сообщения. В действительности, mailbox - это буферизированный канал, размер которого можно задать в момент запуска процесса c помощью [`gen.ProcessOptions`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#ProcessOptions).

### Природа процесса в Ergo Framework

Процессы запускаются и живут в рамках ноды. Каждый процесс имеет свой уникальный идентификатор `etf.Pid`. Он включает в себя имя ноды, уникальный порядковый номер в рамках ноды, а также свойство `Creation`. Этот набор свойств позволяет:

* Идентифицировать процесс даже на удаленной ноде. По имени ноды процесса производится маршрутизация сообщения.
* Свойство `Creation` дает возможность определить "инкарнацию" процесса. Это свойство имеет одинаковое значение для всех запущенных процессов в рамках жизненного цикла ноды. Если нода будет перезапущена, то поле `Creation` будет имееть другое значение (в действительности, в этом поле хранится timestamp запуска ноды).  Eсли отправить сообщение процессу с идентификатором `etf.Pid`, принадлещему предыдущей инкарнации ноды, то вернется ошибка `node.ErrProcessIncarnation`.

Когда нода создает процесс, она возвращает не объект этого процесса, а интерфейс работы с ним - `gen.Process`. Таким образом достигается изоляция объекта процесса. Интерфейс `gen.Process` включает в себя обширный набор методов для управления процессом, а также отправки асинхронных сообщений. Также, для удобства в `gen.Process` встроен интерфейс `gen.Core` - это набор методов самой ноды (например, методы поиска процесса по имени или по `etf.Pid`, или по алиасу `etf.Alias`). Полный набор методов можно посмотреть в референсной документации для [`gen.Core`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#Core) и [`gen.Process`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#Process).

### Старт процесса

Чтобы запустить новый процесс, необходимо создать объект с встроенным в него behavior:

```go
type Example struct {
    gen.Server
    dataA string
    dataB int
}
```

Cозданный объект с типом `Example` унаследует методы и свойства `gen.Server`, который в свою очередь включает в себя методы `gen.Process`. В качестве базового behavior может быть использован любой из поставляемых с Ergo Framework готовых реализаций (см. раздел [Generic Behaviors](broken-reference)). Вы также можете создавать свои behavior и использовать их для создания объектов процессов. Как это делается описано в разделе [Custom Behavior](../advanced/custom-behavior.md).

Запуск процесса осуществляется методом `Spawn`. Этот метод присутствует в интерфейсах `node.Node` и `gen.Process`. Разница лишь в том, что процесс, запущенный методом `gen.Process.Spawn()` получает информацию о своем родителе. В этом случае метод `gen.Process.Parent()` созданного процесса вернет интефейс `gen.Process` родительского процесса. Этот механизм носит лишь информационных характер и останов родительского процесса никак не влияет на работу дочернего.

Метод Spawn имеет ряд аргументов для запуска процесса:

```go
Spawn(name string,
      opts gen.ProcessOptions,
      object gen.ProcessBehavior, 
      args ...etf.Term) (gen.Process, error)
```

Аргумент `name` определяет имя процесса, под которым он должен быть зарегистрировать в процесса запуска. Если такое имя уже занято другим процессом, то вернется ошибка node.ErrTaken. Это поле можно оставить пустым и воспользоваться методом `gen.Process.Register(name string)` позже.

Аргумент `object`. Здесь стоит обратить внимание на его тип `gen.ProcessBehavior`. Когда вы создаете объект Example он включает в себя набор методов `gen.Server` (а также унаследованный набор методов от `gen.Process`) - все эти методы предназначены для использования вами, как разработчиком. В то же время, этот объект должен удовлетворять интефейсу callback методов `gen.ProcessBehavior`, который используется нодой для тех или иных событий.&#x20;

{% hint style="info" %}
Когда вы создаете объект с встроенным `gen.Server` вы автоматически получаете реализацию интерфейса `gen.ProcessBehavior`. Вместе с этим, gen.Server включает в себя расширенный набор callback методов `gen.ServerBehavior.`Например callback метод`Init(...)` вызывается в момент старта процесса, callback метод`HandleInfo(...)` вызывается когда приходит сообщение этому процессу.
{% endhint %}

Аргумент `args` является вариативным (переменной длины). Он передается в callback метод `Init(process *gen.ServerProcess, args... etf.Term)` в момент старта процесса.&#x20;

Таким образом, код старта процесса будет выглядеть следующим образом:

```go
type Example struct {
    gen.Server
    dataA string
    dataB int
}

func (e *Example) Init(process *gen.ServerProcess, args ... etf.Term) error {
    fmt.Println("Hello! My name is", process.Name())
    fmt.Println("and my PID is", process.Self())
    return nil
}

func main() {
    node, _ := ergo.StartNode("node@localhost", "cookies", node.Options{})
    process, _ := node.Spawn("example", gen.ProcessOptions{}, &Example{})
    node.Stop()
}
```

В данном примере реализован только один callback метод Init, однако gen.Server требует реализации всех методов интефейса gen.ServerBehavior. Почему этот код верный и будет работать? Дело в том, что в реализации gen.Server уже имеются реализации этих методов. Таким способом обеспечивается опциональность их реализации в ваших объектах. Это значит, если вы не реализуете, например, метод:&#x20;

```go
func (e *Example) HandleInfo(process *gen.ServerProcess, message etf.Term) {
    return gen.ServerStatusOK
}
```

то будет задействован метод, реализованный самим gen.Server, который выглядит следующим образом:

```go
func (gs *Server) HandleInfo(process *ServerProcess, message etf.Term) ServerStatus {
    lib.Warning("Server [%s] HandleInfo: unhandled message %#v", process.Name(), message)
    return ServerStatusOK
}
```

В этом случае, при получении сообщения, каждый раз на стандартный вывод будет выводиться предупреждение вида:

```log
2022/05/17 21:05:12 WARNING! Server [example] HandleInfo: unhandled message "hello"
```

В референсной документации к любому behavior вы найдете указания, какие методы являются обязательными, а какие опциональными. Обратите на это внимание, когда будете их использовать.

{% hint style="danger" %}
Если вы используете один и тот же объект для старта нескольких процессов, все данные этого объекта являются разделяемыми для всех этих процессов. Например, в реализации`gen.Supervisor` дочерние процессы запускаются используя один и тот же объект, указанный в спецификации супервизора при его инициализации.&#x20;

В приведенном примере `Example` переменные`dataA` и `dataB` будут разделяемыми между всеми процессами, которые будут запущены с использованием одного и того же объекта \&Example{}.&#x20;

Для приватных данных у каждого gen.ServerProcess процесса имеется [State процесса](process.md#state-processa).
{% endhint %}

Код различных примеров вы можете посмотреть в директории examples исходного кода Ergo Framework. Или в репозитории проекта  [https://github.com/ergo-services/ergo/tree/master/examples](https://github.com/ergo-services/ergo/tree/master/examples).

### Останов процесса

Любой процесс может быть остановлен по ряду причин:

* Через вызов метода `gen.Process.Kill()` - немедленная остановка процесса. Если в момент вызова этого метода процесс был занят вызовом callback метода, то останов процесса произойдет сразу же после завершения работы метода.
* Используя вызов `gen.Process.Exit(reason string)` - это graceful завершение работы процесса с вызовом callback метода `Terminate` в случае `gen.Server`. Этот метод также учитывает флаг TrapExit у процесса. Если он был установлен используя `gen.Process.SetTrapExit(true)`, то в этом случае процесс не завершится, но получит сообщение `gen.MessageExit` в callback `HandleInfo(...)`.
* Произошла отмена родительского контекста. Каждый процесс наследует `context.Context` ноды. Таким образом, если нода была остановлена, то все запущенные процессы в рамках этой ноды также завершат свою работу.&#x20;
* Произошла отмена контекста, заданного через `gen.ProcessOptions`. Это один из удобных способов подмешать внешний контекст процессу. Например, задать время жизни процессу используя `context.WithDeadline` или `context.WithTimeout`.&#x20;
* Произошла паника в процессе работы callback метода. Каждый процесс в Ergo Framework имеет функцию перехвата паники используюя механизм recover. Однако, стоит иметь ввиду, что эти механизмы не могут контролировать goroutin'ы, запущенные за пределами фреймворка. Это значит, что если в них случится паника, то произойдет аварийный останов всего приложения.&#x20;

{% hint style="warning" %}
Механизмы перехвата паники в процессах Ergo Framework не могут контролировать goroutin'ы, запущенные за пределами фреймворка. Это значит, что если в них случится паника, то произойдет аварийный останов всего приложения. Вам необходимо убедиться в безаварийности кода, либо добавить механизм recovery в такие goroutine самостоятельно
{% endhint %}

* Процесс был слинкован с другим процессом, который завершил свою работу. Однако, такое событие можно также перехватить используя флаг TrapExit. Как работает механизм линковки можно почитать в разделе [Links And Monitors](links-and-monitors.md).

### State процесса

