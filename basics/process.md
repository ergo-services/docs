---
description: Что такое процесс в Ergo Framework
---

# Process

Процесс в Ergo Framework - это актор в виде надстройки над легковесной goroutine, в которую включен набор необходимых методов и свойств. Взаимодействие между такими процессами производится с помощью обмена сообщениями. Для этих целей в процессе имеется mailbox, куда помещаются все входящие сообщения. В действительности, mailbox - это буферизированный канал, размер которого можно задать в момент запуска процесса c помощью [`gen.ProcessOptions`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#ProcessOptions).

### Природа процесса

Процессы запускаются и живут в рамках ноды. Каждый процесс имеет свой уникальный идентификатор `etf.Pid`. Он включает в себя имя ноды, уникальный порядковый номер в рамках ноды, а также свойство `Creation`. Этот набор свойств позволяет:

* Идентифицировать процесс даже на удаленной ноде. По имени ноды процесса производится маршрутизация сообщения.
* Свойство `Creation` дает возможность определить "инкарнацию" процесса. Это свойство имеет одинаковое значение для всех запущенных процессов в рамках жизненного цикла ноды. Если нода будет перезапущена, то поле `Creation` будет имееть другое значение (в действительности, в этом поле хранится timestamp запуска ноды).  Eсли отправить сообщение процессу с идентификатором `etf.Pid`, принадлещему предыдущей инкарнации ноды, то вернется ошибка `node.ErrProcessIncarnation`.

Когда нода создает процесс, она возвращает не объект этого процесса, а интерфейс работы с ним - `gen.Process`. Таким образом достигается изоляция объекта процесса. Интерфейс `gen.Process` включает в себя обширный набор методов для управления процессом, а также отправки асинхронных сообщений. Также, для удобства в `gen.Process` встроен интерфейс `gen.Core` - это набор методов самой ноды (например, методы поиска процесса по имени или по `etf.Pid`, или по алиасу `etf.Alias`). Полный набор методов можно посмотреть в референсной документации для [`gen.Core`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#Core) и [`gen.Process`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#Process).

### Старт процесса

Чтобы запустить новый процесс, необходимо создать объект с встроенным в него behavior:

```go
type Example struct {
    gen.Server
    dataA string
    dataB int
}
```

Cозданный объект с типом `Example` унаследует методы и свойства `gen.Server`, который в свою очередь включает в себя методы `gen.Process`. В качестве базового behavior может быть использован любой из поставляемых с Ergo Framework готовых реализаций (см. раздел [Generic Behaviors](broken-reference)). Вы также можете создавать свои behavior и использовать их для создания объектов процессов. Как это делается описано в разделе [Custom Behavior](../advanced/customization/custom-behavior.md).

Запуск процесса осуществляется методом `Spawn`. Этот метод присутствует в интерфейсах `node.Node` и `gen.Process`. Разница лишь в том, что процесс, запущенный методом `gen.Process.Spawn()` получает информацию о своем родителе. В этом случае метод `gen.Process.Parent()` созданного процесса вернет интефейс `gen.Process` родительского процесса. Этот механизм носит лишь информационных характер и останов родительского процесса никак не влияет на работу дочернего.

Метод Spawn имеет ряд аргументов для запуска процесса:

```go
Spawn(name string,
      opts gen.ProcessOptions,
      object gen.ProcessBehavior, 
      args ...etf.Term) (gen.Process, error)
```

Аргумент `name` определяет имя процесса, под которым он должен быть зарегистрировать в процесса запуска. Если такое имя уже занято другим процессом, то вернется ошибка node.ErrTaken. Это поле можно оставить пустым и воспользоваться методом `gen.Process.Register(name string)` позже.

Аргумент `object`. Здесь стоит обратить внимание на его тип `gen.ProcessBehavior`. Когда вы создаете объект Example он включает в себя набор методов `gen.Server` (а также унаследованный набор методов от `gen.Process`) - все эти методы предназначены для использования вами, как разработчиком. В то же время, этот объект должен удовлетворять интефейсу callback методов `gen.ProcessBehavior`, который используется нодой для тех или иных событий.&#x20;

{% hint style="info" %}
Когда вы создаете объект с встроенным behavior `gen.Server` вы автоматически получаете реализацию интерфейса `gen.ProcessBehavior`. Вместе с этим, gen.Server включает в себя расширенный набор callback методов `gen.ServerBehavior.`Например callback метод`Init(...)` вызывается в момент старта процесса, callback метод`HandleInfo(...)` вызывается когда приходит сообщение этому процессу.
{% endhint %}

Аргумент `args` является вариативным (переменной длины). Он передается в callback метод `Init(process *gen.ServerProcess, args... etf.Term)` в момент старта процесса.&#x20;

Таким образом, код старта процесса будет выглядеть следующим образом:

```go
type Example struct {
    gen.Server
    dataA string
    dataB int
}

func (e *Example) Init(process *gen.ServerProcess, args ... etf.Term) error {
    fmt.Println("Hello! My name is", process.Name())
    fmt.Println("and my PID is", process.Self())
    return nil
}

func main() {
    node, _ := ergo.StartNode("node@localhost", "cookies", node.Options{})
    process, _ := node.Spawn("example", gen.ProcessOptions{}, &Example{})
    node.Stop()
}
```

В данном примере реализован только один callback метод `Init`, однако `gen.Server` требует реализации всех методов интефейса `gen.ServerBehavior`. Почему этот код верный и будет работать? Дело в том, что в реализации `gen.Server` уже имеются реализации этих методов. Таким способом обеспечивается опциональность их реализации в ваших объектах. Это значит, если вы не реализуете, например, метод:&#x20;

```go
func (e *Example) HandleInfo(process *gen.ServerProcess, message etf.Term) {
    return gen.ServerStatusOK
}
```

то будет задействован метод, реализованный самим gen.Server, который выглядит следующим образом:

```go
func (gs *Server) HandleInfo(process *ServerProcess, message etf.Term) ServerStatus {
    lib.Warning("Server [%s] HandleInfo: unhandled message %#v", process.Name(), message)
    return ServerStatusOK
}
```

В этом случае, при получении сообщения, каждый раз на стандартный вывод будет выводиться предупреждение вида:

```log
2022/05/17 21:05:12 WARNING! Server [example] HandleInfo: unhandled message "hello"
```

В референсной документации к любому behavior вы найдете указания, какие методы являются обязательными, а какие опциональными. Обратите на это внимание, когда будете их использовать.

{% hint style="danger" %}
Если вы используете один и тот же объект для старта нескольких процессов, все данные этого объекта являются разделяемыми для всех этих процессов. Например, в реализации`gen.Supervisor` дочерние процессы запускаются используя один и тот же объект, указанный в спецификации супервизора при его инициализации.&#x20;

В приведенном примере `Example` переменные`dataA` и `dataB` будут разделяемыми между всеми процессами, которые будут запущены с использованием одного и того же объекта \&Example{}.&#x20;

Для приватных данных у каждого gen.ServerProcess процесса имеется поле State с типом `interface{}`. Вы можете использовать его для любых данных.
{% endhint %}

Код различных примеров вы можете посмотреть в директории `examples` исходного кода Ergo Framework. Или в репозитории проекта [https://github.com/ergo-services/ergo/tree/master/examples](https://github.com/ergo-services/ergo/tree/master/examples).

### Взаимодействие с процессом

Взаимодействие между процессами обеспечивается обменом сообщениями. Для этого можно использовать метод асинхронной отправки сообщений `gen.Process.Send(...)`. В этом случае в процессе-получателе будет вызван callback метод `HandleInfo(...)`. Вместе с тем, behavior `gen.Server` предоставляет два дополнительных метода

* `gen.ServerProcess.Cast(...)` - аналогичный метод `gen.Process.Send(...)`, только в этом случае в процессе получателе будет вызван метод `HandleCast(...)`.  Наличие двух одинаковых по своим свойствам callback методов связано с Erlang. В первую очередь для совместимости с ним. Во вторую, но не менее важную - дать возможность разработчику разделить тип сообщений. Например, для управляющих сообщений использовать `Cast(...)`, для остальных - `Send(...)`
* `gen.ServerProcess.Call(...)` - позволяет делать синхронные запросы к другому процессу. В процессе-получателе будет вызван callback метод `HandleCall(...)`. Возвращаемое значение этим методом будет отправлено инициатору запроса в качестве ответа на запрос.

Eсли необходимо обратиться к процессу из обычного golang-кода (не из другого процесса), то для этого необходимо иметь интерфейс процесса `gen.Process`, который возвращается функцией создания нового процесса `Spawn`. Используя метод `gen.Process.Direct(...)` можно сделать синхронный запрос процессу. В этом случае в процессе-получателе будет вызван callback метод `HandleDirect(...)`. Метод `gen.Process.Direct(...)` доступен только для локальных процессов. Для работы с удаленными процессами необходимо использовать методы `gen.Process.Send(...)`, `gen.ServerProcess.Cast(...)` или `gen.ServerProcess.Call(...)`.

Поскольку интерфейс `gen.Process` встроен в `gen.ServerProcess` это позволяет вам использовать все методы `gen.Process` в рамках `gen.ServerProcess`, в том числе методы `Send` и `Direct`.

### Останов процесса

Любой процесс может быть остановлен по ряду причин:

* Через вызов метода `gen.Process.Kill()` - немедленная остановка процесса. Если в момент вызова этого метода процесс был занят вызовом callback метода, то останов процесса произойдет сразу же после завершения работы метода.
* Используя вызов `gen.Process.Exit(reason string)` - это graceful завершение работы процесса с вызовом callback метода `Terminate` в случае `gen.Server`. Этот метод также учитывает флаг TrapExit у процесса. Если он был установлен используя `gen.Process.SetTrapExit(true)`, то в этом случае процесс не завершится, но получит сообщение `gen.MessageExit` в callback `HandleInfo(...)`.
* Произошла отмена родительского контекста. Каждый процесс наследует `context.Context` ноды. Таким образом, если нода была остановлена, то все запущенные процессы в рамках этой ноды также завершат свою работу.&#x20;
* Произошла отмена контекста, заданного через `gen.ProcessOptions`. Это один из удобных способов подмешать внешний контекст процессу. Например, задать время жизни процессу используя `context.WithDeadline` или `context.WithTimeout`.&#x20;
* Произошла паника в процессе работы callback метода. Каждый процесс в Ergo Framework имеет функцию перехвата паники используя механизм recover. В целях отладки вы можете отключить функцию перехвата паники используя флаг `-ergo.norecover` при старте вашего приложения.

{% hint style="warning" %}
Механизмы перехвата паники в процессах Ergo Framework не могут контролировать goroutin'ы, запущенные за пределами фреймворка. Это значит, что если в них случится паника, то произойдет аварийный останов всего приложения. Вам необходимо убедиться в безаварийности вашего кода, либо добавить механизм recover в такие goroutine самостоятельно
{% endhint %}

* Процесс был слинкован с другим процессом, который завершил свою работу. Однако, такое событие можно также перехватить используя флаг TrapExit. Как работает механизм линковки можно почитать в разделе [Links And Monitors](links-and-monitors.md).
* Для behavior `gen.Server` , если вызванный callback метод `Init` вернул ошибку или любой из callback методов `HandleInfo`, `HandleCast` или `HandleCall` вернул статус отличный от `gen.ServerStatusOK` или `gen.ServerStatusIgnore`.&#x20;
* Для behavior `gen.Application` , если был вызов метода `node.Node.ApplicationStop(name string)`

### Отказоустойчивость

Иногда могут возникать ситуации при которых процесс перестает обрабатывать входящие сообщения или обрабатывает их медленнее, чем поступают новые сообщения. Причины такого поведения могут быть различными. Например, процесс работает с большим объемом данных, с медленной СУБД или возник dead-lock из-за ошибки в логике реализции. В любой из таких ситуаций очередь сообщений переполняется. Для обработки такой ситуации в Ergo Framework есть два сценария:&#x20;

* Вновь приходящие сообщения будут отбрасываться, а на стандартный вывод будет выводиться соответствующее предупреждение:

```log
2022/05/18 19:48:39 WARNING! mailbox of <8500427C.0.1011>["example"] is full. dropped message from <8500427C.0.1011> "hello"
```

* Пресылаться другому процессу, если таковой был указан в опциях запуска процесса как запасной `gen.ProcessOptions.Fallback`. Такие сообщения упаковываются в структуру `gen.MessageFallback`. При этом запасной процесс может быть только локальным.
