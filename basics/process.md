---
description: Что такое процесс в Ergo Framework
---

# Process

Процесс в Ergo Framework - это актор в виде надстройки над легковесной goroutine, в которую включен набор необходимых методов и свойств. Взаимодействие между такими процессами производится с помощью обмена сообщениями. Для этих целей в процессе имеется mailbox, куда помещаются все входящие сообщения. В действительности, mailbox - это буферизированный канал, размер которого можно задать в момент запуска процесса c помощью [`gen.ProcessOptions`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#ProcessOptions).

### Природа процесса

Процессы запускаются и живут в рамках ноды. Каждый процесс имеет свой уникальный идентификатор `etf.Pid`. Он включает в себя имя ноды, уникальный порядковый номер в рамках ноды, а также свойство `Creation`. Этот набор свойств позволяет:

* Идентифицировать процесс даже на удаленной ноде. По имени ноды процесса производится маршрутизация сообщения.
* Свойство `Creation` дает возможность определить "инкарнацию" процесса. Это свойство имеет одинаковое значение для всех запущенных процессов в рамках жизненного цикла ноды. Если нода будет перезапущена, то поле `Creation` будет имееть другое значение (в действительности, в этом поле хранится timestamp запуска ноды).  Eсли отправить сообщение процессу с идентификатором `etf.Pid`, принадлещему предыдущей инкарнации ноды, то вернется ошибка `node.ErrProcessIncarnation`.

Когда нода создает процесс, она возвращает не объект этого процесса, а интерфейс работы с ним - `gen.Process`. Он включает в себя обширный набор методов для управления процессом, а также отправки асинхронных сообщений. Также, для удобства в `gen.Process` встроен интерфейс `gen.Core` - это набор методов самой ноды (например, методы поиска процесса по имени или по `etf.Pid`, или по алиасу `etf.Alias`). Полный набор методов можно посмотреть в референсной документации для [`gen.Core`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#Core) и [`gen.Process`](https://pkg.go.dev/github.com/ergo-services/ergo/gen#Process).

### Старт процесса

Чтобы запустить новый процесс, необходимо создать объект с встроенным в него behavior:

```go
type Example struct {
    gen.Server
    data string
}
```

Cозданный объект с типом `Example` унаследует методы и свойства `gen.Server`, который в свою очередь включает в себя методы `gen.Process`. В качестве базового behavior может быть использован любой из поставляемых с Ergo Framework готовых реализаций (см. раздел [Generic Behaviors](broken-reference)). Вы также можете создавать свои behavior и использовать их для создания объектов процессов. Как это делается описано в разделе [Custom Behavior](../advanced/customization/custom-behavior.md).

Запуск процесса осуществляется методом `Spawn(...)`. Этот метод присутствует в интерфейсах `node.Node` и `gen.Process`. Разница лишь в том, что процесс, запущенный методом `gen.Process.Spawn()` получает информацию о своем родителе. В этом случае метод `gen.Process.Parent()` созданного процесса вернет интерфейс `gen.Process` родительского процесса. Этот механизм носит лишь информационный характер и останов родительского процесса никак не влияет на работу дочернего.

Метод `Spawn` имеет ряд аргументов для запуска процесса:

```go
Spawn(name string,
      opts gen.ProcessOptions,
      object gen.ProcessBehavior, 
      args ...etf.Term) (gen.Process, error)
```

Аргумент `name` определяет имя процесса, под которым должен быть зарегистрирован процесс в момент запуска. Если такое имя уже занято другим процессом, то вернется ошибка node.ErrTaken. Это поле можно оставить пустым и воспользоваться методом `gen.Process.Register(name string)` позже.

Аргумент `object`. Здесь стоит обратить внимание на его тип `gen.ProcessBehavior`. Когда вы создаете объект `Example` он включает в себя набор методов `gen.Server` (а также унаследованный набор методов от `gen.Process`) - все эти методы предназначены для использования вами, как разработчиком. В то же время, этот объект должен удовлетворять интефейсу callback методов `gen.ProcessBehavior`, который используется нодой для запуска процесса.&#x20;

{% hint style="info" %}
Когда вы создаете объект с встроенным behavior `gen.Server` вы автоматически получаете реализацию интерфейса `gen.ProcessBehavior`. Вместе с этим, gen.Server включает в себя расширенный набор callback методов `gen.ServerBehavior.`Например callback метод`Init(...)` вызывается в момент старта процесса, callback метод`HandleInfo(...)` вызывается когда приходит сообщение этому процессу.
{% endhint %}

Аргумент `args` является вариативным (переменной длины). Он передается в callback метод `Init(process *gen.ServerProcess, args... etf.Term)` в момент старта процесса.&#x20;

Таким образом, код старта процесса будет выглядеть следующим образом:

```go
type Example struct {
    gen.Server
    data string
}

func (e *Example) Init(process *gen.ServerProcess, args ... etf.Term) error {
    fmt.Println("Hello! My name is", process.Name())
    fmt.Println("and my PID is", process.Self())
    return nil
}

func main() {
    node, _ := ergo.StartNode("node@localhost", "cookies", node.Options{})
    process, _ := node.Spawn("example", gen.ProcessOptions{}, &Example{})
    node.Stop()
}
```

В данном примере реализован только один callback метод `Init`, однако `gen.Server` требует реализации всех методов интефейса `gen.ServerBehavior`. Почему этот код верный и будет работать? Дело в том, что в реализации `gen.Server` уже имеются реализации этих методов. Таким способом обеспечивается опциональность их реализации в ваших объектах. Это значит, если вы не реализуете, например, метод:&#x20;

```go
func (e *Example) HandleInfo(process *gen.ServerProcess, message etf.Term) {
    return gen.ServerStatusOK
}
```

то будет задействован метод, реализованный самим gen.Server, который выглядит следующим образом:

```go
func (gs *Server) HandleInfo(process *ServerProcess, message etf.Term) ServerStatus {
    lib.Warning("Server [%s] HandleInfo: unhandled message %#v", process.Name(), message)
    return ServerStatusOK
}
```

В этом случае, при получении сообщения, каждый раз на стандартный вывод будет выводиться предупреждение вида:

```log
2022/05/17 21:05:12 WARNING! Server [example] HandleInfo: unhandled message "hello"
```

В референсной документации к любому behavior вы найдете указания, какие методы являются обязательными, а какие опциональными. Обратите на это внимание, когда будете их использовать.

{% hint style="danger" %}
Среди всех behavior важно отметить `gen.Application`. Методы `node.Node.Spawn(...)` и `gen.Process.Spawn(...)` не смогут запустить процесс с использованием объекта на базе `gen.Application`. Они всегда будут возвращать ошибку `"ProcessInit: not an ApplicationBehavior"`. Для запуска процесса-приложение в интерфейсе `node.Node` существуют специальные методы `ApplicationLoad`, `ApplicationStart` и т.д. Более подробно о приложениях, их свойствах и методах работы с ними вы можете почитать в разделе [Application](../generic-behaviors/application.md).
{% endhint %}

### State процесса

Если вы используете один и тот же объект для старта нескольких процессов, все данные этого объекта являются разделяемыми для всех этих процессов. Например, в реализации`gen.Supervisor` дочерние процессы запускаются используя один и тот же объект, указанный в спецификации супервизора при его инициализации.&#x20;

Для приватных данных у каждого gen.ServerProcess процесса имеется поле State с типом `interface{}`. Вы можете использовать его для любых данных.

Ниже приведен пример, демонстрирующий разделяемые данные и приватные для процессов, запущенных используя один и тот же объект

```go
type private struct {
   i int
}

type Example struct {
	gen.Server
	shared int
}

func (e *Example) Init(process *gen.ServerProcess, args ...etf.Term) error {	
	process.State = &private{i: 123} 
	e.shared = 567
	return nil
}
func (e *Example) HandleCast(process *gen.ServerProcess, message etf.Term) gen.ServerStatus {
	state := process.State.(*private)
	fmt.Printf("[%s] HandleCast: %#v\n", process.Self(), state)
	return gen.ServerStatusOK
}
```

В данном примере поле `shared` в объекте будeт разделяемым между всеми процессами, которые будут запущены с использованием одного и того же объекта `&Example{}`. Вместе с тем, `process.State` будет хранить приватные данные доступные только самому процессу.

### Взаимодействие с процессом

Взаимодействие между процессами обеспечивается обменом сообщениями. Для этого можно использовать метод асинхронной отправки сообщений `gen.Process.Send(...)`. В этом случае в процессе-получателе будет вызван callback метод `HandleInfo(...)`. Вместе с тем, behavior `gen.Server` предоставляет два дополнительных метода

* `gen.ServerProcess.Cast(...)` - аналогичный метод `gen.Process.Send(...)`, только в этом случае в процессе получателе будет вызван метод `HandleCast(...)`.  Наличие двух одинаковых по своим свойствам callback методов связано с Erlang. В первую очередь для совместимости с ним. Во вторую, но не менее важную - дать возможность разработчику разделить тип сообщений. Например, для управляющих сообщений использовать `Cast(...)`, для остальных - `Send(...)`
* `gen.ServerProcess.Call(...)` - позволяет делать синхронные запросы к другому процессу. В процессе-получателе будет вызван callback метод `HandleCall(...)`. Возвращаемое значение этим методом будет отправлено инициатору запроса в качестве ответа на запрос.

Eсли необходимо обратиться к локальному процессу из обычного golang-кода (не из другого процесса), то для этого необходимо иметь интерфейс процесса `gen.Process`, который возвращается функцией создания нового процесса `Spawn`. Используя метод `gen.Process.Direct(...)` можно сделать синхронный запрос процессу. В этом случае в процессе-получателе будет вызван callback метод `HandleDirect(...)`. Метод `gen.Process.Direct(...)` доступен только для локальных процессов. Для отправки асинхронного сообщения используйте метод `gen.Process.Send(...)`.&#x20;

Для работы с удаленными процессами из обычного golang-кода можно использовать только метод `gen.Process.Send(...)`

Поскольку интерфейс `gen.Process` встроен в `gen.ServerProcess` это позволяет вам использовать все методы `gen.Process` в рамках `gen.ServerProcess`, в том числе методы `Send` и `Direct`.

### Останов процесса

Любой процесс может быть остановлен по ряду причин:

* Через вызов метода `gen.Process.Kill()` - немедленная остановка процесса. Если в момент вызова этого метода процесс был занят вызовом callback метода, то останов процесса произойдет сразу же после завершения работы callback метода. В этом случае callback метод `Terminate` у завершаемого `gen.Server` процесса не вызывается.
* Используя вызов `gen.Process.Exit(reason string)` - это graceful завершение работы процесса с вызовом callback метода `Terminate` в случае `gen.Server`. Этот метод также учитывает флаг TrapExit у процесса. Если он был установлен используя `gen.Process.SetTrapExit(true)`, то в этом случае процесс не завершится, но получит сообщение `gen.MessageExit` в callback `HandleInfo(...)`.
* Произошла отмена родительского контекста. Каждый процесс наследует `context.Context` ноды. Таким образом, если нода была остановлена, то все запущенные процессы в рамках этой ноды также завершат свою работу.&#x20;
* Произошла отмена контекста, заданного через `gen.ProcessOptions`. Это один из удобных способов подмешать внешний контекст процессу. Например, задать время жизни процессу используя `context.WithDeadline` или `context.WithTimeout`.&#x20;
* Произошла паника в процессе работы callback метода. Каждый процесс в Ergo Framework имеет функцию перехвата паники используя механизм recover. В целях отладки вы можете отключить функцию перехвата паники используя флаг `-ergo.norecover` при старте вашего приложения.

{% hint style="warning" %}
Механизмы перехвата паники в процессах Ergo Framework не могут контролировать goroutin'ы, запущенные за пределами фреймворка. Это значит, что если в них случится паника, то произойдет аварийный останов всего приложения. Вам необходимо убедиться в безаварийности вашего кода, либо добавить механизм recover в такие goroutine самостоятельно
{% endhint %}

* Процесс был слинкован с другим процессом, который завершил свою работу. Однако, такое событие можно также перехватить используя флаг TrapExit. Как работает механизм линковки можно почитать в разделе [Links And Monitors](links-and-monitors.md).
* Для behavior `gen.Server` , если вызванный callback метод `Init` вернул ошибку или любой из callback методов `HandleInfo`, `HandleCast` или `HandleCall` вернул статус отличный от `gen.ServerStatusOK` или `gen.ServerStatusIgnore`.&#x20;
* Для behavior `gen.Application` , если был вызов метода `node.Node.ApplicationStop(name string)`

### Mailbox процесса

Иногда могут возникать ситуации при которых процесс перестает обрабатывать входящие сообщения или обрабатывает их медленнее, чем поступают новые сообщения. Причины такого поведения могут быть различными. Например, процесс работает с большим объемом данных, с медленной СУБД или возник dead-lock из-за ошибки в логике реализции. При возникновении переполнения очереди на стандартный вывод будет выводиться соответствующее предупреждение:

```log
2022/05/18 19:48:39 WARNING! mailbox of <8500427C.0.1011>["example"] is full. dropped message from <8500427C.0.1011> "hello"
```

В некоторый случаях решить эту проблему вам может помочь увеличение размера очереди сообщений, используя параметр `gen.ProcessOptions.MailboxSize` при старте процесса. Eсли это не помогает, то вы можете задействовать опцию `gen.ProcessOptions.Fallback`. Она определяет запасной процесс для обработки входящий сообщений. В этом случае, при переполнении очереди сообщений все входящие сообщения будут упаковываться в структуру `gen.MessageFallback` и пересылаться на указанный запасной процесс.

{% hint style="info" %}
Запасной процесс, определяемый в gen.ProcessOptions.Fallback, может быть только локальным
{% endhint %}

Обратите внимание на поле `Tag` в структуре `gen.ProcessFallback`. Оно позволяет дифференцировать сообщения, если несколько процессов используют один и тот же запасной процесс.

### Родительский процесс и лидер группы

Процессы, запущенные с использованием метода `node.Node.Spawn(...)` не имеют ни родительского процесса (`gen.Process.Parent()` вернет `nil`), ни лидера группы (метод `gen.Process.GroupLeader()` также вернет `nil`)

Если процесс был запущен процессом с помощью `gen.Process.Spawn(...)`, то он получает родительский процесс и метод `gen.Process.Parent()` вернет `gen.Process` интерфейс родительского процесса.

Ессли процесс стартует как часть группы процессов, запускаемых с помощью `gen.Application`, то лидером группы устанавливается процесс `gen.Application`, запускающий эту группу процессов.&#x20;

Также, лидера группы для процесса можно установить через `gen.ProcessOptions.GroupLeader` в момент запуска процесса.

{% hint style="info" %}
Наличие или отсутствие у процесса родительского процесса или лидера группы никак не влияет на сам процесс и носит лишь информационный характер. Вы можете использовать информацию о родительском процессе или лидере группы в логике реализации вашего приложения.
{% endhint %}

### Переменные окружения

Каждый процесс имеет переменные окружения. Получить список этих переменных можно используя метод `gen.Process.ListEnv()` или получить значение по заданному имени переменной с помощью `gen.Process.Env(name gen.EnvKey)`.&#x20;

Чтобы установить переменные окружения процесса можно использовать несколько способов:

* Задать переменные окружения ноды. Либо при старте ноды используя `node.Options.Env`, либо используя методы `node.Node.SetEnv(...)`. Они автоматически наследуются всеми процессами, запускаемыми на этой ноде
* Задать переменные окружения в лидере группы. Для behavior `gen.Application` они могут быть определены в моменте инициализации с помощью `gen.ApplicationSpec.Env`
* Задать переменные окружения в родительском процессе, который запускает этот процесс
* Используя опцию `gen.ProcessOptions.Env` при запуске процесса
* Динамически, в процессе жизни процесса, используя метод `gen.Process.SetEnv(...)`

Схематически, наследование переменных окружения можно изобразить следующим образом:

`Process[ Parent[ GroupLeader[ Node ] ] ]`

Таким образом, на каждом этапе наследования переменные могут быть определены или переопределены.

{% hint style="info" %}
Иногда процессу необходимо иметь доступ к методам node.Node. Например, задать статический маршрут, или прокси-маршрут. Для этих целей, каждый процесс при запуске получает переменную окружения `node.EnvKeyNode`, которая хранит в себе интерфейс `node.Node`
{% endhint %}

Пример получения значения переменной окружения `node.EnvKeyNode`:

```go
node := process.Env(node.EnvKeyNode).(node.Node)
```
